// 隐式属性
// [[scope]] 作用域链
//1. 函数创建时生成的一个js内部的隐式属性 由js引擎读取
//2. 存储函数作用域链的容器 
//   作用域链（AO 函数的执行期上下文, GO 全局的执行期上下文）
// 每次执行函数，会形成新的AO。

function a() {
  function b() {
    var b = 2;
  }
  var a = 1;
  b()
}
var c = 3;
a();

// 1.当a函数被定义时(全局在执行的时候)，a内部生成[[scope]]属性，其保存的是该函数的作用域链
// 该作用域链的第0位存储的是当前环境的全局执行期上下文GO，GO里存储的有 --- this，window，document，a，c
// 2.当a函数被执行时（前一刻）
// 该作用域链的顶端（第0位）存储a函数生成的函数执行上下文AO（AO的形成过程同learn-5小节里预编译一样），而GO被存储到第一位。
// 3.a函数执行时，b函数被定义（还未被执行），此时[[scope]]的形成也同a一样,最外层先有a的作用域链，最后执行的时候，再有自己的执行上下文 添加进去，形成b自己的作用域链
// 4.此时作用域链条真正形成，变量的查找从作用域链的顶端依次向下查找
// 5.b函数执行完 b函数的AO被销毁 回归为被定义时的状态
// 6.a函数执行完，a函数的AO被销毁，回归为被定义时的状态 b函数的[[scope]]不复存在
// 7.全局执行完 全局GO销毁， a函数的scope也不复存在
// ! 任何函数作用域链[[scope]]的顶端 都是自己的AO


// !闭包
// 1. 当test1函数执行结束时，因为test2被返回到外部，且被test3接收，此时test1的AO并未被销毁，(但是test1的作用域链与它的AO之间的连线断了)
// 2. 因为仍然被test2引用着 即test2的[[scope]]作用域链条连接着
// 3. 运行test3 test2的AO形成，[[scope]]链条完整形成，且保留着test1的AO
// 4. 当test3执行结束后， test2的AO被销毁，而test1的AO仍然存在且被test2连着
// ! 闭包的本质就是使原来的作用域链中的AO不释放
function test1() {
  function test2() {}
  return test2
}

let test3 = test1()
test3()


