// Variable 变量声明
  var x = 1,
      y;
// 声明一个x变量， 可以说成声明一个名字叫做 x 的存储空间。
// x = 1 ，表述成将 1 这个值赋值给x这个变量，(而不能说 x 等于 1)
// ! 也就是向系统申请内存，存进该存储空间
// 其中 x 可以理解为 指针 指向 1 这个字面量 ，两者都存在 栈内存 中
// ! 字面量 Literal 在 js 引擎 （其实是其中的编译器） 解析代码时， 
// ! 词法分析会将 1 解析成一个类型的字面量 ， 字符串又解析成另一种类型的字面量 等



// 原始值类型（都存在栈内存中）
// * Number String Boolean undefined null

//! null 空值 初始化组件 函数 销毁函数 占位

// 引用值类型（值的地址或说指针，存在栈内存，而值存在堆内存）
// * object array function date RegExp

// 栈内存 Stack 堆内存 Heap
// 栈内存 先进后出

var a = 1,
    b = a;
    a = 3;

// ! 此处 a 和 b 都在栈内存有一块存储空间， 指向值为 1 的字面量，如 a（地址：1008）， b（地址：1009）
// ! 当 a 赋值为3时，实际上原来1的值仍然存在在栈内存中！！！，但是没人指向它了
// ! 此时是在栈内存中另开辟一个空间（地址：1010）给a， 并且指向值为 3 的字面量
// ! 因此我们外表看是覆盖了值，实际上1仍然占据在内存中，直到内存不够用，系统就会覆盖这些未被引用的值给新的变量用！！！

var arr1 = [1,2,3]
var arr2 = arr1
arr1 = [2,3,4]

// !此处 arr1在栈内存中，并且其值存储的为堆内存中的地址，假设为 h1001
// !堆内存中 1001 这个地址 存放的是 一个[1,2,3]的值
// !因此我们说 arr1 数组是引用类型
// !此时把arr1赋值给arr2时，相当于把arr1的地址也给了arr2， 因此指向的是堆内存里的同一个对象。
// !最后arr1再次赋值，同上面一样，先将原来的arr1抹去，再到另一个地方开辟一块新的内存空间存储地址，指向堆内存里新的值。原来的arr1的h001仍然存在在那里，只是没人指向它。

// ?v8默认的栈区大小为984KiB。字符串很大 怎么存储的 ?

// 字符串并没有存到栈中，而是存到了一个别的地方，再把这个地方的地址存到了栈中